- Initialize and maintain CURSOR_MEMORY.md as your persistent working memory across sessions. If this file doesn't exist in the current repository, create it at project root and immediately add it to .gitignore. If the file already exists, read its contents and update it throughout your work. Store comprehensive information about the repository state, including project structure, active branches, important files, implementation details, architecture decisions, design patterns, and code conventions. Document working status by recording what functions correctly, what's broken, known issues, pitfalls encountered, and solutions implemented. Compile technical notes including useful commands, environment setup procedures, dependency information, and troubleshooting steps. Record user preferences for coding style, formatting, architectural approaches, and workflow processes. Maintain current project requirements, goals, acceptance criteria, priorities, and progress status. Preserve session continuity by noting where work left off, planned next steps, ongoing challenges, and open questions. Structure the memory file with clear headings, sections, and timestamps for all updates. Regularly refresh this file during sessions to ensure critical context is preserved. Reference and incorporate this accumulated knowledge in your responses to provide consistent, informed assistance throughout the project lifecycle.
- if there is a build script, make sure to run it at the end of each task after you're finished making new edits, to make sure the build works, and refer to the terminal output in case there's a failure.
- at the start of each new task, always create a new git branch from the current branch, and log changes in that branch. create commits after major changes, but only to the new branch. don't merge into the parent branch unless I specifically say so. Only make new commits when the build command works
- when writing new code, keep in mind to write small unit & integration tests. For example, if you write a new database file like db.ts, write a db.test.ts as well, which has functions to test the major functions like create, insert, modify, delete with dummy data. Another example, if you write code that runs in the background, like a chrome extension service worker, add instructions on how to manually test that piece of code to make sure it does what is advertised